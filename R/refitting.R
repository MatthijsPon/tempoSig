#' Refit spectra using MutationalCone
#' 
#' Given input spectra, find proportions of known signatures
#' 
#' Adopted from Omichessan et al. 
#' \url{http://dx.doi.org/10.1371/journal.pone.0221235}.
#' 
#' @param catalog Input matrix of dimension \code{(M, N)}, where
#'        \code{M} is the no. of genetic features, e.g., 96 for SNV trinucleotides)
#'        and \code{N} is the number of samples to refit
#' @param signatures Matrix of dimension \code{(M,K)} with \code{K} reference 
#'        signatures in columns (e.g., COSMIC signatures).
#' @param normalize Normalize output column-wise
#' @return Matrix of dimension \code{(K, N)} with columns giving estimated
#'         loading of signatures in each sample.
#' @export
mutationalCone <- function(catalog, signatures='COSMIC.v2', normalize=FALSE){
  
  if(is.character(signatures)){
    if(signatures=='COSMIC.v2'){
      fl <- system.file('extdata/COSMIC_SNV_signatures_v2.txt', package = 'tempoSig')
      signatures <- as.matrix(read.table(file =fl, header = TRUE, sep = '\t'))
    }
  } else if(!is.matrix(signatures)) stop('Input signature not a matrix')
  
  if(sum(is.na(rownames(catalog))) > 0) stop('Rows of catalog must be named')
  if(NROW(catalog)!=NROW(signatures)) 
    stop('Dimension of catalog does not match signature')
  idx <- match(rownames(signatures), rownames(catalog))
  if(sum(is.na(idx)) > 0) stop('Row names of catalog do not match signature')
  catalog <- as.matrix(catalog[idx, , drop = FALSE])
  
  # Orthonormalization of the subspace generated by reference signatures 
  S <- signatures 
  S.qr <- qr(S)
  Q <- qr.Q(S.qr) # orthonormal basis of the subspace
  R <- qr.R(S.qr) # components of the reference signatures in the orthonormal basis
  
  # Projection of the catalogue onto the subspace generated by
  # reference signatures 
  proj.subspace <- t(Q) %*% catalog
  
  # Projection onto the cone spanned by the signatures
#  weights <- as.vector(coneproj::coneB(y = as.vector(proj.subspace),
#                                       delta = R)$coefs)
  weights <- apply(proj.subspace, MARGIN=2, 
                   FUN=function(x){ 
                     as.vector(coneproj::coneB(y = as.vector(x), delta = R)$coefs)
                   })
  
  rownames(weights) <- colnames(signatures)
  colnames(weights) <- colnames(catalog)
  if(normalize) weights <- t(t(weights)/colSums(weights))
  if(NCOL(weights)==1) weights <- weights[,1]
  
  return(weights)
}

#' Cosine similarity
#' @param A Test matrix of dimension \code{(m,a)} 
#' @param B Reference matrix of dimension \code{(m, b)}
#' @return Matrix of dimension \code{(a,b)}, whose elements give overlap of column \code{a}
#'         in matrix \code{A} with column \code{b} in matrix \code{B}.
#' @export
CosineSimilarity <- function(A, B){
  
  a <- NCOL(A)
  b <- NCOL(B)
  cos <- matrix(0, nrow=a, ncol=b)
  for(i in seq(1,a)) for(j in seq(1,b))
    cos[i,j] <- sum(A[,i]*B[,j]) / sqrt(sum(A[,i]^2) * sum(B[,j]^2))
  
  return(cos)
}